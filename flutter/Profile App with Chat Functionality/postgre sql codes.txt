-- Create profiles table to store user data
CREATE TABLE profiles (
    user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    age INTEGER NOT NULL CHECK (age > 0),
    email TEXT NOT NULL,
    profile_pic_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Enable Row Level Security (RLS) on profiles table
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to view their own profile
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT
    USING (auth.uid() = user_id);

-- Policy: Allow users to insert their own profile
CREATE POLICY "Users can insert their own profile" ON profiles
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);

-- Policy: Allow users to update their own profile
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE
    USING (auth.uid() = user_id);

-- Create storage bucket for profile pictures
INSERT INTO storage.buckets (id, name, public)
VALUES ('profile_pics', 'profile_pics', true)
ON CONFLICT (id) DO NOTHING;

-- Policy: Allow public read access to profile pictures
CREATE POLICY "Allow public read on profile pics"
ON storage.objects FOR SELECT
USING (bucket_id = 'profile_pics');

-- Policy: Allow authenticated users to upload their own profile picture
CREATE POLICY "Allow user to upload own profile pic"
ON storage.objects FOR INSERT
WITH CHECK (
    bucket_id = 'profile_pics'
    AND auth.uid()::text = split_part(name, '.', 1)
);

-- Policy: Allow authenticated users to update their own profile picture
CREATE POLICY "Allow user to update own profile pic"
ON storage.objects FOR UPDATE
USING (
    bucket_id = 'profile_pics'
    AND auth.uid()::text = split_part(name, '.', 1)
);

-- Policy: Allow authenticated users to delete their own profile picture
CREATE POLICY "Allow user to delete own profile pic"
ON storage.objects FOR DELETE
USING (
    bucket_id = 'profile_pics'
    AND auth.uid()::text = split_part(name, '.', 1)
);

-- Create index on user_id for performance (optional, as PRIMARY KEY already indexes)
CREATE INDEX IF NOT EXISTS profiles_user_id_idx ON profiles (user_id);


-- Drop the old select policy if it exists
DROP POLICY IF EXISTS "Users can view their own profile" ON profiles;

-- New Policy: Allow authenticated users to view all profiles
CREATE POLICY "Authenticated users can view all profiles" ON profiles
    FOR SELECT
    USING (auth.role() = 'authenticated');

-- Create index on user_id for performance (optional, as PRIMARY KEY already indexes)
CREATE INDEX IF NOT EXISTS profiles_user_id_idx ON profiles (user_id);

-- New table for friend requests
CREATE TABLE friend_requests (
    id SERIAL PRIMARY KEY,
    from_user UUID NOT NULL REFERENCES profiles(user_id) ON DELETE CASCADE,
    to_user UUID NOT NULL REFERENCES profiles(user_id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Enable RLS on friend_requests
ALTER TABLE friend_requests ENABLE ROW LEVEL SECURITY;

-- Policy: Allow authenticated users to insert their own requests
CREATE POLICY "Users can insert friend requests" ON friend_requests
    FOR INSERT
    WITH CHECK (auth.uid() = from_user);

-- Policy: Allow users to view their own sent and received requests
CREATE POLICY "Users can view own requests" ON friend_requests
    FOR SELECT
    USING (auth.uid() = from_user OR auth.uid() = to_user);

-- Policy: Allow receivers to update status of requests
CREATE POLICY "Receivers can update request status" ON friend_requests
    FOR UPDATE
    USING (auth.uid() = to_user);

-- New table for friendships (undirected, using CHECK to avoid duplicates)
CREATE TABLE friendships (
    user1 UUID NOT NULL REFERENCES profiles(user_id) ON DELETE CASCADE,
    user2 UUID NOT NULL REFERENCES profiles(user_id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user1, user2),
    CHECK (user1 < user2)
);

-- Enable RLS on friendships
ALTER TABLE friendships ENABLE ROW LEVEL SECURITY;

-- Policy: Allow authenticated users to insert friendships (but in practice, this will be done after accepting requests)
CREATE POLICY "Users can insert friendships" ON friendships
    FOR INSERT
    WITH CHECK (true); -- Since we'll handle logic in code, but restrict to authenticated

-- Policy: Allow users to view their own friendships
CREATE POLICY "Users can view own friendships" ON friendships
    FOR SELECT
    USING (auth.uid() = user1 OR auth.uid() = user2);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS friend_requests_from_user_idx ON friend_requests (from_user);
CREATE INDEX IF NOT EXISTS friend_requests_to_user_idx ON friend_requests (to_user);
CREATE INDEX IF NOT EXISTS friendships_user1_idx ON friendships (user1);
CREATE INDEX IF NOT EXISTS friendships_user2_idx ON friendships (user2);

-- New Policy: Allow users to delete their own friendships
CREATE POLICY "Users can delete own friendships" ON friendships
FOR DELETE
USING (auth.uid() = user1 OR auth.uid() = user2);

-- Enable Realtime for friend_requests table
ALTER PUBLICATION supabase_realtime ADD TABLE friend_requests;
-- Optionally, enable Realtime for friendships table if needed in the future
ALTER PUBLICATION supabase_realtime ADD TABLE friendships;

-- Add policy for senders to cancel (delete) pending friend requests
CREATE POLICY "Senders can cancel pending requests" ON friend_requests
    FOR DELETE
    USING (auth.uid() = from_user AND status = 'pending');